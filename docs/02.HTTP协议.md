## HTTP简介

- HTTP是Hyper Text Transfer Protocol（超文本传输协议）的缩写。HTTP协议用于从WWW服务器传输超文本到本地浏览器的传送协议。它可以使浏览器更加高效，使网络传输减少。它不仅保证计算机正确快速地传输超文本文档，还确定传输文档中的哪一部分，以及哪部分内容首先显示(如文本先于图形)等。HTTP是一种用作获取诸如 HTML 文档这类资源的协议。它是 Web 上进行任何数据交换的基础，同时，也是一种客户端—服务器（client-server）协议，也就是说，请求是由接受方——通常是浏览器——发起的。一个完整网页文档是由获取到的不同文档组件——像是文本、布局描述、图片、视频、脚本等——重新构建出来的。

## HTTP概述

- HTTP是一个是基于TCP/IP协议之上的应用层协议，由请求和响应构成，是一个标准的客户端服务器模型。HTTP是一个无状态的协议。客户端与服务端之间通过交换一个个独立的消息（而非数据流）进行通信。由客户端——通常是个浏览器——发出的消息被称作请求（request），由服务端发出的应答消息被称作响应（response）。

### 基于请求-响应的模式

- HTTP协议是基于TCP/IP协议之上的应用层协议。它基于“请求-响应”模式。HTTP协议规定,请求从客户端发出,最后服务器端响应该请求并返回。换句话说,肯定是先从客户端开始建立通信的,服务器端在没有接收到请求之前不会发送响应。

### 无状态保存

- HTTP是一种不保存状态,即无状态(stateless)协议。HTTP协议自身不对请求和响应之间的通信状态进行保存。也就是说在HTTP这个级别,协议对于发送过的请求或响应都不做持久化处理。使用HTTP协议,每当有新的请求发送时,就会有对应的新响应产生。协议本身并不保留之前一切的请求或响应报文的信息。

- HTTP虽然是无状态协议,但为了实现期望的保持登录等状态的功能，引入了Cookie技术。有了Cookie再用HTTP协议通信,就可以管理状态了。

### 无连接

- 无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间，并且可以提高并发性能，不能和每个用户建立长久的连接，请求一次相应一次，服务端和客户端就中断了。

- 无连接有两种方式，早期的 HTTP 协议是一个请求一个响应之后，直接就断开了，但是现在的 HTTP 协议1.1版本不是直接就断开了，而是等几秒钟，如果用户在这几秒钟之内有新的请求，那么还是通过之前的连接通道来收发消息，如果过了这几秒钟用户没有发送新的请求，那么就会断开连接，这样可以提高效率，减少短时间内建立连接的次数，因为建立连接也是耗时的。

## HTTP工作原理

HTTP协议定义Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。HTTP协议采用了请求/响应模型。客户端向服务器发送一个请求报文，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。

1. 客户端连接到Web服务器

一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口（默认为80）建立一个TCP套接字连接。

2. 发送HTTP请求

通过TCP套接字，客户端向Web服务器发送一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求数据4部分组成。

3. 服务器接受请求并返回HTTP响应

Web服务器解析请求，定位请求资源。服务器将资源复本写到TCP套接字，由客户端读取。一个晌应由状态行、响应头部、空行和响应数据4部分组成。

4. 释放连接TCP连接

若connection模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接;若connection模式为keepalive，则该连接会保持段时间，在该时间内可以继续接收请求;

5. 客户端浏览器解析HTML内容

客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取响应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口中显示。

## HTTP请求（Request）格式

- Request消息分为3部分：Request line、Request header、Body。Request header和Body之间有个空行。

### Request line

- 请求的第一行是“方法 URL 协议 / 版本”。例如：GET/sample.jsp HTTP/1.1
    - 以上代码中，“ GET ”代表请求方法
    - “ /sample.jsp ”表示 URI 
    - “ HTTP/1.1 代表协议和协议的版本。
    - 根据 HTTP 标准， HTTP 请求可以使用多种请求方法。

- 在Internet应用中，最常用的方法是GET和POST。

- URI完整地指定了要访问的网络资源，通常只要给出相对于服务器的根目录的相对目录即可，因此总是以“/”开头，最后，协议版本声明了通信过程中使用HTTP的版本。


### URL

- URL由三部分组成：资源类型、存放资源的主机域名、资源文件名。

#### 语法格式

`protocol :// hostname[:port] / path / [;parameters][?query]#fragment`

#### protocol（协议）

指定使用的传输协议

- http 通过 HTTP 访问该资源。 格式 HTTP://
- https 通过安全的 HTTPS 访问该资源。 格式 HTTPS://

一般来说，https开头的URL要比http开头的更安全，因为这样的URL传输信息是采用了加密技术。

#### hostname（主机名）

是指存放资源的服务器的域名系统(DNS) 主机名或 IP 地址。有时，在主机名前也可以包含连接到服务器所需的用户名和密码（格式：username:password@hostname）。

#### port（端口号）

HTTP缺省工作在TCP协议80端口，用户访问网站http:// 打头的都是标准HTTP服务。HTTPS缺省工作在TCP协议443端口。

#### path（路径）

由零或多个“/”符号隔开的字符串，一般用来表示主机上的一个目录或文件地址。

#### parameters（参数）

这是用于指定特殊参数的可选项。

#### query(查询)

可选，用于给动态网页（如使用CGI、ISAPI、PHP/JSP/ASP/ASP。NET等技术制作的网页）传递参数，可有多个参数，用“&”符号隔开，每个参数的名和值用“=”符号隔开。

#### fragment（信息片断）

信息片断，字符串，用于指定网络资源中的片断。例如一个网页中有多个名词解释，可使用fragment直接定位到某一名词解释。

#### 注意

Windows 主机不区分 URL 大小写，但是，Unix/Linux 主机区分大小写。

### HTTP请求方法

- HTTP/1.1协议中共定义了八种方法（也叫“动作”、“动词”、“谓词”)来以不同方式操作指定的资源。

#### GET

向指定的资源发出显示"请求。使用GET方法应该只用在读取数据，而不应当被用于产生"副作用"的操作中，例如在Web Application中。其中一个原因是GET可能会被网络蜘蛛等随意访问。

#### HEAD

与GET方法一样，都是向服务器发出指定资源的请求。只不过服务器将不传回资源的本文部分。它的好处在于，使用这个方法可以在不必传输全部内容的情况下，就可以获取其中“关于该资源的信息”(元信息或称元数据)。

#### POST

向指定资源提交数据，请求服务器进行处理（例如提交表单或者上传文件)。数据被包含在请求本文中。这个请求可能会创建新的资源或修改现有资源，或二者皆有。

#### PUT

向指定资源位置上传其最新内容。

#### DELETE

请求服务器删除Request-URI所标识的资源。

#### TRACE

回显服务器收到的请求，主要用于测试或诊断。

#### OPTIONS

这个方法可使服务器传回该资源所支持的所有HTTP请求方法。用"*"来代替资源名称，向Web服务器发送OPTIONS请求，可以测试服务器功能是否正常运作。

#### CONNECT

HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。通常用于SSL加密服务器的链接（经由非加密的HTTP代理服务器)。

#### 注意事项:

- 方法名称是区分大小写的。当某个请求所针对的资源不支持对应的请求方法的时候，服务器应当返回状态码405(Method NotAllowed)，当服务器不认识或者不支持对应的请求方法的时候，应当返回状态码501(Not lmplemented)。
- HTTP服务器至少应该实现GET和HEAD方法，其他方法都是可选的。当然，所有的方法支持的实现都应当匹配下述的方法各自的语义定义。此外，除了上述方法，特定的HTTP服务器还能够扩展自定义的方法。例如PATCH(由RFC 5789指定的方法)用于将局部修改应用到资源。
- GET提交的数据会放在URL之后，也就是请求行里面，以?分割URL和传输数据，参数之间以&相连，如EditBook?name=test1&id=123456.(请求头里面那个content-type做的这种参数形式，后面讲)POST方法是把提交的数据放在HTTP包的请求体中.
- GET提交的数据大小有限制(因为浏览器对URL的长度有限制)，而POST方法提交的数据没有限制.

### Request header

请求头包含许多有关的客户端环境和请求正文的有用信息。例如，请求头可以声明浏览器所用的语言，请求正文的长度等。
```
Accept:image/gif.image/jpeg.*/*
Accept-Language:zh-cn
Connection:Keep-Alive
Host:localhost
User-Agent:Mozila/4.0(compatible:MSIE5.01:Windows NT5.0)
Accept-Encoding:gzip,deflate.
```

### Request body

- 请求头和请求正文之间是一个空行，这个行非常重要，它表示请求头已经结束，接下来的是请求正文。请求正文中可以包含客户提交的查询字符串信息：`username=foo&password=1234`
- 在以上的例子的HTTP请求中，请求的正文只有一行内容。当然，在实际应用中，HTTP请求正文可以包含更多的内容。

关于HTTP请求方法，这里只讨论GET方法与POST方法：

### GET方法

- GET方法是默认的HTTP请求方法，我们日常用GET方法来提交表单数据，然而用GET方法提交的表单数据只经过了简单的编码，同时它将作为URL的一部分向Web服务器发送，因此，如果使用GET方法来提交表单数据就存在着安全隐患上。例如: `Http://127.0.0.1/login.jsp?Name=zhangshi&Age=30&Submit=%cc%E+%BD%BB`

- 从上面的URL请求中，很容易就可以辩认出表单提交的内容。（？之后的内容）另外由于GET方法提交的数据是作为URL请求的一部分所以提交的数据量不能太大。

### POST方法

- POST方法是GET方法的一个替代方法，它主要是向Web服务器提交表单数据，尤其是大批量的数据。POST方法克服了GET方法的一些缺点。
- 通过POST方法提交表单数据时，数据不是作为URL请求的一部分而是作为标准数据传送给Web服务器，这就克服了GET方法中的信息无法保密和数据量太小的缺点。
- 因此，出于安全的考虑以及对用户隐私的尊重，通常表单提交时采用POST方法。
- 从编程的角度来讲，如果用户通过GET方法提交数据，则数据存放在QUERY_STRING环境变量中，而POST方法提交的数据则可以从标准输入流中获取。

## HTTP 响应（Response）格式

- Response消息的结构和Request结构基本一样。同样也为三部分：Response Line、Response header、Body。Response header和Body之间也有个空行。

### Response line

- Response 消息中的第一行叫做状态行，由“ HTTP协议版本号， 状态码， 状态消息 ”三部分组成，各元素之间以空格分隔。

### HTTP状态码

所有HTTP响应的第一行都是状态行，依次是当前HTTP版本号，3位数字组成的状态代码，以及描述状态的短语，彼此由空格分隔。

- 状态码用来告诉HTTP客户端,HTTP服务器是否产生了预期的Response
- 状态代码的第一个数字代表当前响应的类型

#### 1xx消息

— 请求已被服务器接收，继续处理

#### 2xx成功

- 请求已成功被服务器接收、理解、并接受

#### 3xx重定向

- 需要后续操作才能完成这一请求

#### 4xx请求错误

- 请求含有词法错误或者无法被执行

#### 5xx服务器错误

- 服务器在处理某个正确请求时发生错误

虽然 RFC2616 中已经推荐了描述状态的短语，例如"200 OK"，“404 Not Found”，但是WEB开发者仍然能够自行决定采用何种短语，用以显示本地化的状态描述或者自定义信息。

#### 常用具体示例

- 200 OK：最常见的就是成功响应状态码200了， 这表明该请求被成功地完成，所请求的资源发送回客户端。

- 302 Found：重定向，新的URL会在response 中的Location中返回，浏览器将会自动使用新的URL发出新的Request。

- 304 Not Modified：代表上次的文档已经被缓存了， 还可以继续使用。

- 400 Bad Request：客户端请求与语法错误，不能被服务器所理解。

- 401 Unauthorized ：请求未经授权。这个状态代码必须和WWW-Authenticate报头域一起使用

- 403 Forbidden： 服务器收到请求，但是拒绝提供服务。服务器通常会在响应正文中给出不提供服务的原因。

- 404 Not Found：请求的资源不存在，例如，输入了错误的URL。

- 500 Internal Server Error： 服务器发生不可预期的错误，导致无法完成客户端的请求。

- 503 Server Unavailable： 服务器当前不能够处理客户端的请求，在一段时间之后，服务器可能会恢复正常。

### Response header

Location：Location响应报头域用于重定向接受者到一个新的位置。例如：客户端所请求的页面已不存在原先的位置，为了让客户端重定向到这个页面新的位置，服务器端可以发回Location响应报头后使用重定向语句，让客户端去访问新的域名所对应的服务器上的资源。当我们在JSP中使用重定向语句的时候，服务器端向客户端发回的响应报头中，就会有Location响应报头域。

Server：Server响应报头域包含了服务器用来处理请求的软件信息。它和User-Agent请求报头域是相对应的，前者发送服务器端软件的信息，后者发送客户端软件(浏览器)和操作系统的信息。下面是Server响应报头域的一个例子：Server: Apache-Coyote/1.1

WWW-Authenticate：WWW-Authenticate响应报头域必须被包含在401(未授权的)响应消息中，这个报头域和前面讲到的Authorization请求报头域是相关的，当客户端收到401响应消息，就要决定是否请求服务器对其进行验证。如果要求服务器对其进行验证，就可以发送一个包含了 Authorization报头域的请求，下面是WWW-Authenticate响应报头域的一个例子：WWW-Authenticate: Basic realm="Basic Auth Test!"从这个响应报头域，可以知道服务器端对我们所请求的资源采用的是基本验证机制。

Content-Encoding：Content-Encoding实体报头域被使用作媒体类型的修饰符，它的值指示了已经被应用到实体正文的附加内容编码，因而要获得Content- Type报头域中所引用的媒体类型，必须采用相应的解码机制。Content-Encoding主要用语记录文档的压缩方法，下面是它的一个例子： Content-Encoding: gzip。如果一个实体正文采用了编码方式存储，在使用之前就必须进行解码。

Content-Language：Content-Language实体报头域描述了资源所用的自然语言。Content-Language允许用户遵照自身的首选语言来识别和区分实体。如果这个实体内容仅仅打算提供给丹麦的阅读者，那么可以按照如下的方式设置这个实体报头域：Content-Language: da。如果没有指定Content-Language报头域，那么实体内容将提供给所以语言的阅读者。

Content-Length：  Content-Length实体报头域用于指明正文的长度，以字节方式存储的十进制数字来表示，也就是一个数字字符占一个字节，用其对应的ASCII码存储传输。
要注意的是：这个长度仅仅是表示实体正文的长度，没有包括实体报头的长度。

Content-Type实体报头域用语指明发送给接收者的实体正文的媒体类型。例如：Content-Type: text/html;charset=ISO-8859-1

PS：这里主要关注Content-Length和Content-Type两种类型，用于提取Body实体。

Last-Modified实体报头域用于指示资源最后的修改日期及时间。

Expires实体报头域给出响应过期的日期和时间。通常，代理服务器或浏览器会缓存一些页面。当用户再次访问这些页面时，直接从缓存中加载并显示给用户，这样缩短了响应的时间，减少服务器的负载。为了让代理服务器或浏览器在一段时间后更新页面，我们可以使用Expires实体报头域指定页面过期的时间。当用户又一次访问页面时，如果Expires报头域给出的日期和时间比Date普通报头域给出的日期和时间要早(或相同)，那么代理服务器或浏览器就不会再使用缓存的页面而是从服务器上请求更新的页面。不过要注意，即使页面过期了，也并不意味着服务器上的原始资源在此时间之前或之后发生了改变。
