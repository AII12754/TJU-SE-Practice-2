# 线上点餐平台前端需求分析详尽报告





## 第 1 部分：基础架构与全局需求



本基础部分旨在为前端应用程序建立一套全局性的交互规则。它定义了架构约束、安全协议和通用行为，这些将指导后续所有功能的开发。遵循这些原则对于构建一个可扩展、安全且可维护的应用程序至关重要。



### 1.1 推导的 RESTful API 架构概述





#### 核心原则



前端将与一个严格遵循 REST (Representational State Transfer) 原则的后端进行交互。这意味着所有的 API 端点（Endpoint）都围绕资源（使用名词，如 `/users`、`/orders`）进行设计，而不是动作（使用动词，如 `/createUser`）。交互将利用标准的 HTTP 方法：`GET` 用于检索数据，`POST` 用于创建数据，`PUT`/`PATCH` 用于更新数据，`DELETE` 用于移除数据。

该架构是无状态的（Stateless）。服务器不维护客户端的会话状态，因此前端发出的每个请求都必须包含服务器处理该请求所需的所有信息，例如身份验证令牌。



#### 基础 URL 与版本控制



所有 API 调用都将以一个基础路径和一个版本号作为前缀，例如 `https://api.yourplatform.com/api/v1/`。根据行业最佳实践，这种策略确保了未来的破坏性变更可以在新版本中引入（例如 `/v2/`），而不会干扰现有的前端应用程序。



#### 架构模式



后端被假定遵循微服务架构（Microservices Architecture），其中不同的服务（如用户服务、订单服务等）处理特定的业务领域。前端将与一个单一的 API 网关（API Gateway）进行交互，由网关将请求路由到相应的下游服务。这种模式简化了前端的逻辑，因为它不需要知道单个微服务的地址，同时也将认证和速率限制等共同关注点集中处理。

这种以 API 网关为单一入口点的设计，直接决定了前端的错误处理策略。由于前端只与网关通信，而下游的微服务（如订单服务或餐厅服务）可能会独立失败，一个设计良好的网关不会直接暴露内部服务器错误。它会捕获来自失败微服务的错误，并返回一个标准化的、通用的 `503 Service Unavailable` 或 `500 Internal Server Error` 响应。因此，前端必须实现一个全局错误处理器，能够优雅地处理任何 API 调用可能出现的通用服务器端故障。UI 不能假定只有某些特定功能会失败，而应在出现此类错误时，向用户显示非技术性的友好提示（例如，“系统遇到一些技术问题，请稍后重试”）并提供一个请求ID以便于技术支持追踪问题。这使得前端的稳定性与后端架构的内部状态实现了解耦。



### 1.2 认证与授权协议 (JWT)





#### 基于令牌的认证



所有需要认证的端点都将使用 JSON Web Tokens (JWT) 进行保护。JWT 将通过 `Bearer` 模式在每个请求的 `Authorization` 头中发送。



#### 认证流程



1. 用户通过 `/auth/login` 端点提交凭证（`email`, `password`）。
2. 服务器验证凭证。成功后，返回两个令牌：一个短期的 **访问令牌 (Access Token)**（例如，15分钟有效期）和一个长期的 **刷新令牌 (Refresh Token)**（例如，7天有效期）。
3. 访问令牌的载荷（Payload）将包含非敏感的用户信息，如 `userId`、`role` (`CUSTOMER`, `MERCHANT`, `ADMIN`) 和一个过期时间戳 (`exp`)。根据安全准则，绝不能在 JWT 载荷中存储敏感数据。



#### 安全的令牌存储



为了降低安全风险，前端将采用一种混合存储策略，这是当前业界公认的最佳实践：

- **访问令牌** 将存储在内存中（例如，在状态管理库的一个 JavaScript 变量里）。这可以有效防止其被 `localStorage` 或 `sessionStorage` 持久化，从而避免跨站脚本攻击（XSS）轻易获取到令牌。
- **刷新令牌** 将存储在一个安全的、设置了 `HttpOnly` 标志的 Cookie 中。`HttpOnly` 标志使得该 Cookie 无法通过客户端 JavaScript 访问，从而阻止了 XSS 攻击窃取它。同时，`Secure` 标志确保该 Cookie 只通过 HTTPS 传输，而 `SameSite=Strict` 标志则提供了针对跨站请求伪造（CSRF）攻击的强力保护。



#### 令牌刷新机制



当一个 API 调用因为访问令牌过期而返回 `401 Unauthorized` 错误时，一个全局的 API 客户端拦截器（Interceptor）应能自动、静默地调用 `/auth/refresh` 端点。此请求不发送任何请求体，而是依赖于浏览器自动携带 `HttpOnly` 的刷新令牌 Cookie。服务器验证刷新令牌后，会签发一个新的访问令牌，并可能返回一个新的刷新令牌（以实现令牌旋转安全策略）。随后，最初失败的请求将使用新的访问令牌自动重试。整个过程对用户应该是无感知的。



#### 登出



用户执行登出操作时，前端必须显式调用 `/auth/logout` 端点。这将通知服务器使刷新令牌失效（例如，将其标识符加入黑名单），同时客户端需要从内存中清除访问令牌。



### 1.3 全局错误处理与客户端策略





#### 标准化错误响应结构



所有 API 的错误响应（4xx 和 5xx 状态码）都必须遵循一个一致的 JSON 结构，以便前端进行可预测的错误处理。该结构应包含足够的信息以支持调试和向用户提供有意义的反馈。

JSON

```
{
  "status": "error",
  "statusCode": 404,
  "error": {
    "code": "RESOURCE_NOT_FOUND",
    "message": "请求的餐厅不存在。",
    "details": { "restaurantId": "123" },
    "suggestion": "请检查餐厅ID后重试。",
    "documentationUrl": "https://docs.yourplatform.com/errors/RESOURCE_NOT_FOUND"
  },
  "requestId": "uuid-v4-for-tracing"
}
```



#### 客户端错误分类与用户反馈



- **网络错误** (例如，`fetch` 失败)：UI 必须显示一个全局的、非侵入式的通知（如 Toast 或 Banner），指明连接问题，并对关键请求实施带指数退避算法的重试机制。
- **客户端错误 (4xx)**：这些通常是用户可以恢复的错误。
  - `400 Bad Request` / `422 Unprocessable Entity`：通常用于表单验证失败。UI 必须解析响应中的 `error.details` 字段（其中包含字段特定的错误信息），并在相应的表单字段旁边显示内联错误提示。
  - `401 Unauthorized`：由令牌刷新机制处理。如果刷新失败，必须将用户重定向到登录页面。
  - `403 Forbidden`：用户已认证但无权执行操作。UI 应显示明确的“访问被拒绝”信息，并阻止该操作。
  - `404 Not Found`：UI 应显示用户友好的“未找到”页面或组件（例如，“抱歉，我们找不到您想找的餐厅”）。
- **服务器错误 (5xx)**：从用户的角度来看，这些是不可恢复的错误。UI 必须显示一个通用的、表示歉意的消息（“我们的服务器出了一些问题，请稍后重试”），并提供 `requestId` 以便用户向客服求助。绝不能在前端展示敏感的后端堆栈跟踪信息。

为了提升用户体验和系统性能，前端必须在所有用户输入表单上实施主动的客户端验证。仅仅依赖后端验证会导致可预测的错误（如电子邮件格式不正确、必填字段为空）也需要一次完整的网络往返，这是一种低效的“话痨式”交互模式。这种模式不仅增加了服务器负载，还因为用户操作（提交表单）和反馈（看到错误）之间的延迟而降低了用户体验。因此，前端需求必须强制规定，在发起 API 调用之前，对所有用户输入进行与后端验证规则一致的客户端校验。这为用户创建了一个更快的反馈循环，减少了因无效数据产生的 API 流量，并使应用程序感觉更灵敏、更健壮。



## 第 2 部分：顾客应用程序



本部分详细说明了面向顾客的 Web 和移动应用程序的需求，涵盖了从发现餐厅到订单完成后的整个用户旅程。设计必须是响应式的，以确保在所有设备上提供无缝的体验。



### 2.1 用户引导与个人资料管理





#### 流程与功能



- **注册**：提供一个多步骤的表单，用于邮箱/密码注册。必须包含对电子邮件格式、密码强度和必填字段的客户端验证。同时，应支持社交媒体账户（如 Google、Apple）的单点登录（SSO）功能。
- **登录**：一个用于输入邮箱和密码的简单表单。
- **密码重置**：一个“忘记密码”流程，通过向用户邮箱发送一个包含安全链接的邮件来启动密码重置。
- **个人资料管理**：一个专门的区域，用户可以在此查看和编辑他们的姓名、电话号码和头像。
- **地址管理**：一个支持增删改查（CRUD）操作的界面，用于管理多个配送地址。需要与地图服务（如 Google Places API）集成，以实现地址自动补全和验证。
- **支付管理**：一个安全的界面，用于添加、查看和移除支付方式（如信用卡）。这将通过与符合 PCI 标准的支付提供商（如 Stripe 或 Braintree）集成来实现。前端将使用其提供的 SDK 对敏感信息进行标记化（Tokenization），确保原始银行卡信息永远不会触及我们的应用服务器。



#### API 交互与错误处理



每个流程都将映射到特定的 API 端点。例如，更新用户个人资料将涉及一个 `PUT /users/{userId}` 调用。错误处理必须覆盖各种场景，如注册时的“邮箱已存在”（`409 Conflict`）、登录时的“凭证无效”（`401 Unauthorized`）以及添加地址时的“地址无效”（`400 Bad Request`）。



### 2.2 餐厅与菜单发现





#### 流程与功能



- **餐厅列表**：主屏幕将根据用户的地理位置（通过浏览器定位或手动输入的地址获取）显示附近的餐厅列表。列表必须支持分页加载，以处理大量的餐厅数据。
- **搜索与筛选**：一个醒目的搜索栏，允许用户搜索餐厅或特定的菜品。必须提供高级筛选选项，以便用户按菜系、价格范围、评分和配送时间等条件缩小结果范围。
- **餐厅详情页**：点击一家餐厅将导航至其专属页面，显示其名称、横幅图片、地址、营业时间、评分和完整菜单。
- **菜单导航**：菜单必须按类别（如开胃菜、主菜）进行组织。每个菜单项必须显示其名称、描述、价格和高质量的图片。对于有可定制选项（即规格/配料，Modifiers）的菜品，必须有明确的标识。



#### API 交互与错误处理



- `GET /restaurants?lat=...&long=...&cuisine=...`：使用查询参数进行筛选和分页，获取餐厅列表。
- `GET /restaurants/{restaurantId}`：获取单个餐厅的详细信息，包括其完整菜单。
- 错误处理必须能优雅地处理用户拒绝定位服务、根据给定条件未找到餐厅或特定餐厅菜单加载失败等情况。UI 应显示信息丰富的空状态或错误消息。



### 2.3 购物车与结账流程





#### 流程与功能



- **添加商品**：用户可以从菜单中将商品添加到购物车。如果商品有规格/配料选项（如尺寸、配料），必须弹出一个模态框供用户选择。小计金额应实时更新。
- **购物车管理**：一个在整个应用中都可见的持久化购物车图标，应显示当前的商品数量。点击该图标会打开一个详细的购物车视图，用户可以在此调整数量、移除商品或添加特殊备注。
- **结账漏斗**：这是一个多步骤流程：
  1. **核对订单**：最后检查商品和数量。
  2. **应用优惠码**：提供一个输入框以应用折扣码。
  3. **选择配送地址**：从已保存的地址中选择或添加新地址。
  4. **选择支付方式**：从已保存的支付方式中选择。
  5. **最终确认**：在下单前，显示包括商品小计、配送费、税费和最终总额在内的完整摘要。



#### API 交互与错误处理



结账流程需要一系列的 API 调用，如 S35 和 B2 中所述。

- `POST /carts`：创建一个新的购物车会话。
- `POST /carts/{cartId}/items`：添加商品。
- `PUT /carts/{cartId}/items/{itemId}`：更新数量。
- `DELETE /carts/{cartId}/items/{itemId}`：移除商品。
- `POST /carts/{cartId}/promotions`：应用优惠码。
- `POST /orders`：最终提交，将购物车转换为订单。



#### 关键错误处理



这个流程是潜在错误最集中的地方。前端必须处理：

- 当购物车中的商品库存不足时，返回 `409 Conflict`。UI 必须清晰地标记出不可用的商品，并阻止用户结账，直到该商品被移除。
- 当优惠码无效时，返回 `400 Bad Request`。
- 当支付失败时，返回 `402 Payment Required`。UI 必须显示来自支付网关的具体错误信息（例如，“余额不足”、“银行卡被拒”）。



#### 表 2.3.1：购物车与订单提交 API 端点



这张表格对开发者至关重要，因为它将复杂的结账流程分解为清晰、分步的 API 交互序列。它作为一个直接的实现指南，将每个用户操作映射到一个特定的端点，并定义了预期的数据契约和潜在的失败模式。这消除了模糊性，并显著加快了开发速度。

| 功能         | HTTP 方法 | 端点                                    | 请求体结构                                                  | 成功响应 (2xx)                         | 错误响应 (4xx/5xx)                                           |
| ------------ | --------- | --------------------------------------- | ----------------------------------------------------------- | -------------------------------------- | ------------------------------------------------------------ |
| 创建购物车   | `POST`    | `/api/v1/carts`                         | `{ "items": [...] }`                                        | `201 Created` - 返回新创建的购物车对象 | `400 Bad Request` - 无效的商品数据                           |
| 添加商品     | `POST`    | `/api/v1/carts/{cartId}/items`          | `{ "productId": "...", "quantity": 1, "modifiers": [...] }` | `200 OK` - 返回更新后的购物车对象      | `404 Not Found` (购物车不存在), `400 Bad Request` (无效商品), `409 Conflict` (商品库存不足) |
| 更新商品数量 | `PUT`     | `/api/v1/carts/{cartId}/items/{itemId}` | `{ "quantity": 2 }`                                         | `200 OK` - 返回更新后的购物车对象      | `404 Not Found` (购物车或商品不存在), `409 Conflict` (库存不足) |
| 移除商品     | `DELETE`  | `/api/v1/carts/{cartId}/items/{itemId}` | (无)                                                        | `200 OK` - 返回更新后的购物车对象      | `404 Not Found` (购物车或商品不存在)                         |
| 应用优惠码   | `POST`    | `/api/v1/carts/{cartId}/promotions`     | `{ "promoCode": "DISCOUNT10" }`                             | `200 OK` - 返回应用了折扣的购物车对象  | `404 Not Found` (购物车不存在), `400 Bad Request` (优惠码无效或已过期) |
| 设置配送地址 | `POST`    | `/api/v1/carts/{cartId}/addresses`      | `{ "type": "shipping", "address": {...} }`                  | `200 OK` - 返回更新后的购物车对象      | `404 Not Found` (购物车不存在), `400 Bad Request` (地址格式无效) |
| 设置支付方式 | `POST`    | `/api/v1/carts/{cartId}/paymentMethods` | `{ "method_code": "stripe", "method_name": "Credit Card" }` | `200 OK` - 返回更新后的购物车对象      | `404 Not Found` (购物车不存在), `400 Bad Request` (支付方式无效) |
| 提交订单     | `POST`    | `/api/v1/orders`                        | `{ "cartId": "..." }`                                       | `201 Created` - 返回新创建的订单对象   | `402 Payment Required` (支付失败), `409 Conflict` (购物车状态已改变，如商品售罄) |

导出到 Google 表格



### 2.4 订单完成后体验





#### 流程与功能



- **订单确认**：成功下单后，立即显示一个确认页面，包含订单号和预计送达时间。
- **实时订单追踪**：一个可视化的追踪器，显示订单在各个阶段的进展：`PLACED` (已下单) -> `ACCEPTED_BY_RESTAURANT` (商家已接单) -> `PREPARING` (准备中) -> `READY_FOR_PICKUP` (可取餐) -> `OUT_FOR_DELIVERY` (配送中) -> `DELIVERED` (已送达)。需要一个地图视图来实时显示配送员的位置。
- **订单历史**：一个包含所有过去和进行中订单的列表，允许用户查看详情并一键重新下单。
- **评分与评论**：订单送达后，应提示用户对食物和配送体验进行评分，并留下文字评论。



#### API 交互与错误处理



实时追踪功能要求从传统的 REST 模式转向事件驱动的通信方式。用户期望无需手动刷新页面就能立即获取订单状态更新。如果客户端反复轮询一个 `GET /orders/{orderId}` 端点，会产生极度低效的“话痨式”API 调用，这不仅会使服务器过载，还会浪费客户端资源。这正是 S7 中描述的那种反复询问“午餐好了吗？”的低效场景。因此，前端必须采用事件驱动的方法，例如 WebSockets。下单后，前端将建立一个 WebSocket 连接。后端将实时地向客户端推送状态更新事件（如 `order.status.updated`）。前端必须负责管理 WebSocket 的整个生命周期：连接、监听消息、解析事件、更新 UI，以及优雅地处理断开和重连。这是由实时追踪这一核心用户体验需求驱动的一个基本的前端架构决策。



## 第 3 部分：商家（餐厅）仪表盘



此应用程序是为餐厅员工设计的专业工具。UI 必须针对速度和清晰度进行优化，以便在桌面或平板设备上高效管理大批量订单。



### 3.1 商家认证与引导





#### 流程与功能



为商家用户提供专用的登录入口。为新商家提供一个设置向导，用于配置其餐厅资料（名称、地址、菜系类型）、上传验证文件以及提供用于收款的银行信息。



#### API 交互



`POST /auth/merchant/login`, `PUT /merchants/{merchantId}/profile`, `POST /merchants/{merchantId}/payout-details`。错误处理将覆盖无效登录、文件上传失败和银行信息无效等情况。



### 3.2 实时订单管理





#### 流程与功能



- **新进订单仪表盘**：一个主视图，实时显示新进订单，并伴有声音和视觉提醒。
- **订单操作**：商家必须能够一键接受或拒绝订单。如果拒绝，必须提供理由（例如，“太忙”、“商品缺货”）。
- **状态更新**：接受订单后，商家必须能够更新订单在其生命周期中的状态（例如，`PREPARING` -> `READY_FOR_PICKUP`）。
- **订单历史与搜索**：一个可搜索和筛选所有历史订单的视图。



#### API 交互与错误处理



与顾客应用的追踪功能类似，此模块**必须**使用 WebSockets 来即时接收新订单。对于关键业务功能，REST 轮询是不可接受的。订单操作将通过 REST 调用执行：`POST /orders/{orderId}/accept`, `POST /orders/{orderId}/reject`, `POST /orders/{orderId}/status`。错误处理必须解决网络中断（可能导致漏单）和更新订单状态时的 API 失败。UI 必须有清晰的指示器来显示其与实时服务的连接状态。



### 3.3 菜单与库存控制





#### 流程与功能



一个全面的菜单管理 CRUD 界面。

- **菜单结构**：管理菜品分类、分类下的菜品，以及与菜品关联的规格/配料组（例如，“配料”、“尺寸”）。
- **菜品详情**：编辑菜品名称、描述、价格和图片。
- **可用性开关**：一个简单的开关，用于将菜品或规格/配料标记为“售罄”。此操作必须立即阻止顾客点购该商品。



#### API 交互与错误处理



将使用标准的 CRUD 端点：`GET /merchants/{merchantId}/menu`, `POST /menu/items`, `PUT /menu/items/{itemId}`, `DELETE /menu/items/{itemId}`。一个特定的端点，如 `PUT /menu/items/{itemId}/availability`，将处理库存变更。需要处理的错误包括验证失败（例如，价格为负数）和更新过程中的服务器错误。

菜单项的可用性是一个具有即时、平台范围连锁效应的横切关注点。当商家通过其仪表盘将某个商品标记为“售罄”时，这不仅仅是一个局部状态的改变。这个信息必须立即在整个系统中传播。如果一个顾客的购物车里有这个商品，他必须被通知，并且该商品应在所有活跃的菜单上被禁用。试图添加该商品的顾客应该看到它已不可用。因此，商家仪表盘的前端需求不仅仅是发送一个 `PUT` 请求，还必须处理来自后端的确认，确保可用性变更已成功处理并传播。在顾客端，应用程序必须在进入支付流程前，根据最新的可用性重新验证购物车。这意味着 `GET /restaurants/{restaurantId}` 菜单端点必须始终返回实时的可用性状态，并且结账流程必须包含一个最终的、针对此实时数据的购物车验证步骤。这可以防止一种常见的导致顾客不满和运营失败的根源。



### 3.4 分析与报告





#### 流程与功能



一个显示关键绩效指标（KPI）的仪表盘，如总销售额、订单数和平均订单价值，并可选择时间范围（日、周、月）。提供关于热销商品和顾客反馈/评分的报告。



#### API 交互



`GET /merchants/{merchantId}/analytics?range=...`。前端将负责使用图表库（如 Chart.js, D3.js）渲染这些数据。UI 必须在获取数据时处理加载状态，并在所选时间段内没有数据时显示空状态。



## 第 4 部分：管理员后台



这是整个平台的中央指挥中心，专为业务和运营人员设计。UI 必须优先考虑数据密度、强大的搜索/筛选功能和批量操作能力。



### 4.1 平台级用户管理





#### 流程与功能



一个所有顾客和商家的主视图。管理员必须能够搜索、筛选、查看详情，并执行诸如暂停账户或代表用户重置密码等操作。一个独立的区域用于管理管理员账户及其角色/权限（RBAC）。



#### API 交互



`GET /admin/users`, `PUT /admin/users/{userId}/status`, `GET /admin/merchants`, `PUT /admin/merchants/{merchantId}/status`。



### 4.2 平台运营管理





#### 流程与功能



- **商家入驻审核**：一个待处理商家申请的队列，供管理员审核和批准/拒绝。
- **促销活动**：一个用于创建和管理平台级优惠码和折扣的 CRUD 界面。
- **配送区域与费用**：用于定义配送区域（例如，在地图上绘制多边形）和设置相关配送费用的工具。



#### API 交互



`GET /admin/merchants/pending`, `POST /admin/merchants/{merchantId}/approve`, `POST /admin/promotions`。



### 4.3 全面分析与财务监督





#### 流程与功能



一个显示平台整体健康状况的高级仪表盘：总收入、活跃用户、新注册用户、订单量等。提供财务工具来管理商家的佣金率并生成支付报告。



#### API 交互



前端将从一个专用的分析服务 API（例如，`GET /admin/platform/stats`）消费数据。这需要能够处理大型数据集并提供交互式下钻功能的复杂数据可视化组件。



### 4.4 内容与系统配置





#### 流程与功能



一个简单的内容管理系统（CMS）界面，用于编辑静态页面，如“关于我们”、“常见问题”和“服务条款”。一个用于配置全局系统参数的设置面板。



#### API 交互



`GET /content/{pageSlug}`, `PUT /content/{pageSlug}`。此功能的前端可能是一个与 API 集成的富文本编辑器。



## 结论



本报告为线上点餐平台的前端开发提供了一份详尽的需求分析和技术规范。通过推导一个遵循行业最佳实践的 RESTful API 架构，报告为三个核心用户角色——顾客、商家和管理员——定义了完整的功能流程、API 交互模式和全面的错误处理策略。

关键的实施建议包括：

1. **采用严格的 JWT 认证协议**，结合使用内存存储的短期访问令牌和 `HttpOnly` Cookie 存储的长期刷新令牌，以最大化安全性。
2. **建立全局统一的错误处理机制**，能够优雅地处理从网络中断到服务器故障的各类异常，并通过标准化的错误响应结构为用户提供清晰、可操作的反馈。
3. **在关键业务流程中优先采用事件驱动技术**。特别是对于顾客的订单实时追踪和商家的订单接收，必须使用 WebSockets 等技术取代低效的轮询，以确保信息的即时性和卓越的用户体验。
4. **将客户端验证视为核心功能**，在所有用户输入点实施，以减少不必要的 API 请求，提升应用的响应速度和健壮性。

遵循本报告中概述的规范，开发团队将能够构建一个功能强大、安全可靠、用户体验卓越的前端应用程序，该程序与后端服务紧密、高效地集成，为平台的成功奠定坚实的技术基础。